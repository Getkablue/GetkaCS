
CS 1337 - Computer Science for Gamers
Summer 2023

Welcome to the course.

This is a summer course designed to get you up to speed with programming and related concepts. Due to the accelerated pace, this is essentially a crash course. Many full textbooks can (and have) been written on every topic we will cover. 

Therefore, this course will be a rigorous survey of these topics. It is designed to get you both enough practice to do useful things and enough theory to do them properly. By the end of the course, you will be able to work independently on basic to intermediate tasks in software development. You will also be prepared to learn more advanced theory in computer science and engineering, such as core courses at the undergraduate level, or to take on pieces of more complex projects.

While this course is primarily focused on writing software, some information technology concepts will be briefly covered where needed to facilitate expeditious learning.

We will primarily use C, C++ and Python in this course. These have been chosen to improve your understanding of fundamentals while also extending to real-world practice. Hence, I ask that you only do assignments in the requested language. As time allows, we can explore other languages, especially as required for the semester project. 

## Expectations
To succeed in this class, you should be able to devote about an hour per day, on average, over the course of the summer. Of course, this is very flexible, but this (very rough) amount will guarantee that you can master the ideas and have plenty of time left over. Software development can be quite difficult, and some bugs will leave even experienced professionals completely lost for hours to days. However, each setback is an opportunity to learn.

You will be expected to learn tools and techniques as they arise. We will start gently, but by the end of the semester you should be able to understand common modes of working with new tools.

Please read the lecture notes *before* the corresponding lecture. This way, you will come to class well prepared to ask meaningful questions, and it will allow me to give a better lecture which can focus on applications.

Assignments are for *your own enrichment* and are designed to make you think about the problems. For this reason you are expected to do them at your own pace and ask for feedback when needed. I will not necessarily review all of them, though I will do my best to keep an active eye on your submissions.

## Resources
You may consult any resource at any time during this course unless explicitly marked to the contrary. However, you are responsible for learning the material. Do not simply copy-paste solutions from elsewhere. Instead, think about why the solution works. Does it differ from the solution you attempted? Is it applicable to your use-case and environment? If the solution does work, what does that teach you? 

If a problem arises where your intuition is not helpful, I highly recommend to simply use Google. Learning how to phrase technical questions in this way is extremely valuable. In cases where we are working with a specific software library, please also consult that library's online documentation.
Stack Overflow and related sites are an excellent resource, and almost every issue I have ever run across in development has been answered in some way on there before.

Of course, I am also available for questions and hands-on help at basically any time. But please, consider my time and only for help after attempting to solve it yourself. This will enhance your learning. You may also prepare questions for lecture/lab. This benefits everyone, as any question on your mind is likely on someone else's mind, too. Ad-hoc questions during lecture and lab are always welcomed.

This syllabus and slides/notes for the course are freely available. For the best experience I recommend opening these notes in a live markdown viewer, such as [Obsidian](https://obsidian.md/) . It also works as a markdown editor at the same time, useful for writing your solutions.


## Assignment -1
If you are here, then I presume that at some point you have either desired to write software of some kind or you have wondered what is possible to accomplish with software and computing.

Your first (and last) assignment is to propose a semester project for yourself. 

Part of what we will learn in this course is to (reasonably) estimate the complexity of software development tasks. I am not expecting you to be good at this yet. I would just like you to do some basic research on topics that interest you, and come up with one goal which you believe is reasonable to have achieved by the end of the course. Feel free to be ambitious, but please be specific. As time allows we will work together to refine your goals and to shape the rubric for your final project.

During the first lecture we will discuss these projects as a group and see if there is overlap. If so, you may work as a team. The project should increase in complexity accordingly, so please see me.

## Schedule (To Be Revised)

- Brief History of Computing / What is a Program?
- Lab: Installation and Environment Setup
- Language Overview: C
- Control Flow: Conditionals
- Control Flow: Loops
- Functions
- State, Scope and Memory
- Pointers and Indirection
- Arrays
- Revisiting Functions
- Compilation Basics
- Modularization and Linking
- Shared vs Dynamic Linking
- Language Overview: C++
- Classes and Objects
- Composition of Objects 
- Inheritance
- Basic Data Structures
- Time and Space Complexity
- Templates and Generics
- Language Overview: Python
- "Pythonic Code" and Code Style
- Modules and Imports
- Packages and Subpackages
- Overview of the Standard Library
- Working with APIs
- Dependency Management with Pip
- Revisiting C/C++: Dependency Management

