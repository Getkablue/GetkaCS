Object-oriented programming (OOP) wants you to push the object metaphor as much as possible. Fundamentally, it is about *bundling data with the code relevant to it*. If a type exists as a class, that class should also define the operations which are directly relevant to that data.

In this paradigm, you rely heavily on inheritance, polymorphism and on increasingly complex objects which pass data back and forth to one another, where objects are invoking polymorphic behavior of other objects but only relying on the abstract interface between them, a sort of message-passing language. Objects have individual responsibilities, and your program can be modified by simply exchanging one object for another fulfilling the same overall role.

A program in this sense can be thought of as many objects communicating back and forth. Naturally, this is well-suited to simulations and game engines, where objects in code are representing actual objects, but **many** software projects and languages, even those which disown the OOP moniker, still rely on some form of object orientation. It's just too useful a metaphor to completely pass up on, especially once you have a basic set of concepts modeled.

For instance, a Factory object might produce other objects according to a set of parameters or from data saved on disk. These sorts of objects are the "inner machinery" of your program -- a `Factory` is not directly related to your program's goal and overall meaning, but in the OOP paradigm, you have chosen to model most parts of your program as objects, so it seems fitting to turn a "role of responsibility" in your program into an object, even if it doesn't have externally-facing meaning. Even things we think of generally as not being objects, or even stateful, might be represented by objects with names like `Command`s and `Action`s, and might contain their result after they are "executed". More generally some objects might be `DataModel`s, `DataView`s and `DataController`s of various kinds. These are (suitably) abstract, but generally a Model is the underlying data itself, a View represents some "lens" through which the data is being viewed (and often defines variables related to the user's visual of the data) and the Controller is some abstract entity which handles some kind of input to change the View or the Model. 

In OOP, you must understand the following concepts (note that these are not strictly limited to OOP, but form the basis of its philosophy):

*Entanglement*, or *coupling*, is when two or more objects do not make sense without each other. If two objects are *strongly coupled*, they rely on a lot of information about each other in order to function. *Weak coupling* refers to two objects that may rely on each other, but which do not need information about the other's inner workings. This is generally preferable, and helps prevent code that breaks when other unrelated parts of the program change.
For instance, I have a class `Worker` which does various jobs at various rates. We have another thing in our program called a `JobTimeEstimator`. If that `JobTimeEstimator` has the `Worker`'s rates of work hardcoded into it, then the `JobTimeEstimator` is *strongly coupled* to that specific kind of `Worker`. Our program needs to continue to make sense, so, any changes to `Worker` also need to be made in `JobTimeEstimator`. Yuck. You could, instead, give `Worker` an interface which allows the `JobTimeEstimator` to "ask" the worker how long any given task will take. This would weaken the coupling between those two objects.

*Encapsulation* is "information hiding". An object *encapsulates* its inner workings (`private` or `protected` methods and variables) that other objects should not know or care about, and *exposes* (makes `public`) those methods and variables that are needed to fulfill its role. Strong proactive encapsulation prevents entanglement.
For example, a `Worker` from the above example might have a variable `tools` describing the tools available to it. The `JobTimeEstimator` does not really need to know about the `tools` the `Worker` has. By marking `tools` as `protected` or `private`, no external code can come to rely on it. By marking it private, other programmers on your team know that they aren't supposed to rely on `tools` externally. Perhaps there will eventually be a new `Worker` without `tools` but with `drones` instead -- why should other code break when only your `Worker` changes?

*Abstraction* is something we have covered recently, but to reiterate, it is about describing things in terms of the tasks they fulfill, rather than in terms of how they accomplish those tasks. Obviously, we cannot always be abstract. Eventually we must write a *concrete* way to implement those tasks. But it turns out that deferring this is often good. Making good abstractions, before ever knowing the specifics, is the key skill of a *software architect*. 

# Object Oriented Design Principles:

## Favor Composition Over Inheritance
This principle says that, when possible, you should prefer to compose objects (using "has-a" relationships) instead of inheritance ("is-a" relationships). I know, after all that crap about inheritance, I tell you to ignore it?! 

I know, I'm a dick. But there are good reasons. For one, multiple inheritance, as well as chains of single inheritance, can be hard to keep track of, and can even result in the ominously-named [Deadly Diamond of Death](https://en.wikipedia.org/wiki/Multiple_inheritance#The_diamond_problem) . When you are reading the code for a class, you are forced to look elsewhere for inherited or overriding code. For another, inheriting behavior is locked-in statically, so it becomes harder to easily swap out components with different implementations. If you do this based on inheritance, something might suddenly break when you swap out the thing you're inheriting from. You may also be forced to write code in the derived class relating to each and every inherited class (this is especially so when superclass constructors do some necessary setup which you then have to copy-paste into the subclass constructor... remember DRY?). 

By composing component objects instead, each of those objects is responsible for its own behavior -- you only need to set parameters as appropriate to your object, and can rely on defaults otherwise. Your object remains mostly clean of references to behavior it doesn't need to know about. 

You should still use inheritance when it makes sense -- usually when an object needs to be directly usable as an instance of another class. For example, if a library expects a Logger object pointer, so that it can log in whatever way we desire (to a file? to the console? out over the network?), we probably just want to override the original Logger class functionality and pass in a pointer to our child class. But for many cases, composition will result in a cleaner solution overall. 

## SOLID Principles
The SOLID principles are oft-quoted principles in OOP that aim to make software much more maintainable, flexible and improvable. These principles are very helpful and should help guide your design thinking in many cases, not just in OOP. I consider these the most valuable thing to take from the object-oriented paradigm.

### S: Single Responsibility Principle
This principle states that each object should be responsible for only one thing. This helps to prevent huge, monolithic objects which take up 90% of your code. If each object has one, clear responsibility, it makes it much easier to reason about its role in the program and to know where to look when something goes wrong. It also makes it easier for teams, as each person can concern themselves with one component without worrying (as much) about other components.

### O: Open-Closed Principle
This principle states that code you write should be "open for extension, closed for modification". It essentially means that someone should be able to meaningfully extend the behavior of the object without needing to modify its source code directly. Inheritance directly supports this, but this should also inform the way you write code in general -- think about how someone inheriting from your object might want to customize, and what they would want to reuse. 

### L: Liskov Substitution Principle
This principle states that any reference to a base class should be freely interchangeable with those of a child class. Since child classes are more specialized or use a different implementation, but should still fulfill the same basic contract that the parent class promises, using the child class instead of the parent should not break my program. 

For example, if I have a base class `BasicSoundPlayer` and a child class `AdvancedSoundPlayer` (which maybe does some interpolation of sound effects or something), both should still fulfill the role of actually playing the sound and doing any necessary cleanup of sound data in the audio buffer -- my program should not crash or otherwise fail because I made the switch (i.e., should not rely on implementation details of the individual class, or **at least** should make those implementation details which *are* required **very** obvious and clear).

### I: Interface Segregation Principle
This principle states that interfaces should have the smallest possible surface to fulfill their function. That is, interfaces should not be merged together into larger interfaces without good reason. This principle basically helps to ensure that objects are maximally reusable and that interfaces don't end up bloated (or that objects don't end up with interface methods that don't actually apply to them...). 

For example, if you have a food type of item in your program, we might say that food is both edible and decomposable. You might separate these into two interfaces, `IEdible` and `IDecomposable` -- which then allows also for edible items which aren't decomposable or decomposable items which aren't edible. Before you make an interface which inherits both of those interfaces, really determine whether both are *truly* necessary at the same time -- if you make some interface `IFood` which combines `IEdible` and `IDecomposable`, it will only ever include objects which implement both interfaces.

### D: Dependency Inversion Principle
Dependency inversion is also sometimes referred to as dependency injection. This principle is sometimes stated as "your code should depend upon abstractions, not concretions." Basically the idea goes that, instead of your code calling on a specific service, you should instead rely on an abstract interface that service meets, and accept it as a parameter.
For example, let's say I'm making a music player application, and I want to visualize the music in some way. Even if I only have one renderer for this, my `SimpleWaveformVisualizer`, I should not hard-code that into my music player. Instead, my `playTrack` function (or whatever) should take as a parameter anything meeting an `IAudioVisualizer` interface. This way, down the line, we have no problem injecting a different visualizer (`AIGeneratedMusicVideoVisualizer`? `FourierTransformAudioVisualizer`?) for the audio. Even better than that, my audio-playing code is clearer because there isn't visualization code in it, and it doesn't rely on any specific visualization technique. And really, this should make a hell of a lot of sense at some level. You don't *want* to write code that requires you to know about details of some visualizer

# Design Patterns

A "design pattern" is, as the name implies, a common way to design systems. The way it is used here, we generally mean "generic ways of approaching problems in different domains", but some domains have their own associated patterns. Hell, a single developer can have their own favored patterns. In OOP, the nature of objects is of the most importance, so design patterns center around various means of composing objects and their semantics. 

I cannot recommend enough the book [*Game Programming Patterns*](https://gameprogrammingpatterns.com/contents.html) by Bob Nystrom. It is available completely for free on his website, and gives great examples (In appropriately C++ish language) for how you might apply various patterns to situations in games. Even if you don't have interest in making games, these metaphors really help in understanding the patterns and inspiring you to applying them in other situations. The book doesn't exhaustively cover every OOP design pattern, but the ones it does it does very well.

If you are looking for the "canonical" set of OOP design patterns, the classic reference is the book *Design Patterns: Elements of Reusable Object-Oriented Software*. You can find equally good explanations of design patterns from that book in *many* places online (even on Wikipedia). In fact, I strongly recommend you review some of these patterns and try to make sense of them. In the future, I will ask you to evaluate your own programs and determine if you have (intentionally or not) invoked one of these patterns.

In a general sense, the design patterns, applied properly, cost us an increase in complexity "up front" in order to make future design changes require the addition of less complexity. The cost associated with establishing the pattern (and adding any necessary boilerplate, and telling your team members to use it this way), is generally miniscule compared to the complexity of trying to add new features to a system which wasn't made for them. Of course, sometimes you just run into a wall and need to make changes. There is no sin in that.

# Anti-Patterns
An "anti-pattern" is a pattern to be avoided, *especially* a pattern that seems good at first glance but turns out to be limiting later. Again, these can be domain-agnostic or domain-specific. You will basically learn your own anti-patterns as you continue to program and find what kinds of code is hard to work on and which code is easy to work on. If someone just tells you "X is an antipattern" without elaborating on why, and you are using X just fine, tell them to piss off.

In the most general sense, anti-patterns eventually force us to add unwanted complexity to our program. There is no actual "list" of anti-patterns. If they are to be meaningful anti-patterns at all, generally they must at some point have been patterns, and opinions must have shifted about it. To some, OOP in general is an anti-pattern. Only time really tells whether another solution or paradigm really is cleaner and better. While the fad craze around making overcomplicated OOP-jargon-laden nonsense like `AbstractEmployeePrototypeAdapterFactoryFactory` in the 90s has died down, general OO principles have not (at least not yet).

I will give you one important anti-pattern to consider:

## Global State
Global variables are almost always a bad thing. I know, it probably sounds odd at this point of your journey. But global variables are accessible from anywhere in your program. If parts of your program rely on that piece of *global state*, then the behavior of those parts isn't truly known unless we know for sure that the global state will be in a very specific set of states. Remember, the compiler generally can't verify behavior for values, only for types. So using global state kind of separates us from our compiler in some sense. 

Global state hence opens the door to a *lot*, and I mean a *lot* of bugs. Try not to rely on it. If it helps, consider that global state is very inflexible to replacement -- anything that relies on global state is entangled or coupled to that global state. And if multiple things are entangled to global state, that means that those objects are all entangled to each other.


# Conclusion 
We have examined some very useful principles. Obviously, the material here, especially on specific patterns, could be expanded upon endlessly with opinions and examples and alternatives, but this cannot be a textbook on the topic. Instead, when designing a solution, think about these general principles, and check out the design patterns for some inspiration.