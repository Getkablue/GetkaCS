In Lecture 1, you were given the tools to write basic programs. Assignments 0-7 and Labs 0-2 should have helped exercise what you learned. But while these tools can be used to solve almost any problem, we have not yet tackled larger questions about the *modeling* and *design* of programs.

The tools you have been given in the C and C++ languages so far are *far* more than sufficient for Turing completeness -- any task possible via computation is now possible (in principle) for you to program. But that's not exactly helpful, is it? Even if you know it's possible, that doesn't tell you anything about *how* to do it, let alone *the best way* to do it. You are relying on analytical skills to break a problem down into component parts, and then relying on technical skills to translate those parts back into pieces of a solution. Again, a programming language contains tools suitable for solving any computable problem -- it is *domain agnostic*, i.e. it does not matter what area your problem lies in so long as it is computable in principle. Almost anything we can think of dealing with information is computable, so almost all areas fall into this group. 

The process of translating concepts in a specific application area into a form useful for problem-solving is sometimes called *domain modelling*. You have seen this briefly during the assignments when you were asked to model a bank account. Once you have a suitable *model* for your area of interest, whether it's on paper, in code or in your head, then you can start thinking about how to *design a solution* for the problem at hand. Of course, you also need to be able to translate soft, squishy human requirements and processes, from *mere humans* who probably don't understand software, into so-called *business logic*.

It could be said that a great deal of work in software engineering is in (properly) doing this so-called "business analysis" before we even get to design. Of course, the design is paramount, because it gives us our solution -- and we often need to keep our options open for further developing our solution. Techniques for doing this which extend across domains (i.e. which do not require domain-specific knowledge) are therefore very valuable. This is a very volatile field, historically. Most people can agree that they don't want to write programs (or even use models) relying on very low-level details. Hence, abstraction is the name of the game.  But just as everybody thinks about problems in their own way internally, nobody can quite agree which abstractions are best. Many flame wars have been fought, languages split off and projects forked because of these disagreements. All of these, ultimately, are in the name of managing complexity.
Doing this well is something of an art as much it is a science -- this is the *software engineering* skill that sets you apart from a 'mere coder'.

In this chapter, we will discuss and apply some popular paradigms for the design of complex programs in a manageable way. Along the way, we will pick up tricks that we didn't consider previously and think about how the programming language can work for us, rather than the other way around. We will also learn common patterns which can be applied to many sub-problems in many domains, and selectively apply them. We will cap off with an understanding of how the languages we use can guide our own thinking, and reason about modern and upcoming language features.

By the chapter's end, you will be capable of reasoning much more abstractly about the behavior of programs, and apply abstraction to make your own programs far more powerful and flexible. In turn, these skills will grant you the "Rosetta Stone" of software development.